#!/usr/local/bin/perl
# Copyright (c) Feb 2011-2013 Wolfram Schneider, http://bbbike.org
#
# elevation-database - fetch SRTM3 elevation data for points in planet.osm without elevation infos
#

use Storable;
use Getopt::Long;
use LWP::UserAgent;
use IO::File;
use XML::Simple;
use Data::Dumper;

use strict;
use warnings;

######################################################################
# geonames.org API for elevation data:
#
# http://www.geonames.org/export/web-services.html#srtm3
#
# http://api.geonames.org/srtm3?lat=50.01&lng=10.2&username=demo
# http://api.geonames.org/srtm3?lats=50.01,51.01&lngs=10.2,11.2&username=demo
#

my $debug    = 1;
my $database = "";
my $socksproxy;
my $readonly_database = 0;
my $api_url           = 'http://api.geonames.org/srtm3?username=';
my $data_osm_dir      = "data-osm";
my $max_points = 20;                                     # limit of geonames.org
my $user_agent = "BBBike @ World - http://bbbike.org";
my $sleep      = 2.5;
my $check_database;
my $repair_database;
my $exit_on_error = 1;
my $test_mode     = 0;
my $geonames_user = 'bbbike';
my $dump_csv      = 0;

my $csv_delimiter = "\t";

# 5 digits after comma, 1 meter granularity: 9.22951,54.9326
my $granularity = 100_000;

my $ignore_poi = 1;    # use the next cross instead

my $NO_DATA = -32768;

sub usage () {
    my $message = shift;

    warn $message, "\n" if $message;
    die <<EOF;
usage: $0 [options] cities ...

--database=elevation.db | elevation.csv
--socksproxy=socks://host:port   set socks proxy
--geonames-user=user		 set geonames api user
--readonly-database
--data-osm-dir=/path/to/bbbike/data-osm
--user-agent="user agent version xyz"
--sleep=$sleep
--check-database
--repair-database
--exit-on-error=[0,1]
--test-mode
--dump-csv
EOF
}

######################################################################
# helper functions
#

sub hoehe_header {

    return <<EOF;
#: #: -*- coding: utf-8 -*-
#:encoding: utf-8
#:map: polar
#:date: fixed
#:
#
# OpenStreetMap data can be used freely under the terms of the 
# Creative Commons Attribution-ShareAlike 2.0 license.
# http://wiki.openstreetmap.org/index.php/OpenStreetMap_License
#
# Converted from openstreetmap data using
# /home/wosch/projects/bbbike/miscsrc/osm2bbd v0.11
# DO NOT EDIT THIS FILE! Edit the original openstreetmap data!
#
EOF
}

sub Die {
    my $message = shift;
    warn $message;
    alarm(0);
    exit(1);
}

sub retrieve_csv {
    my $database = shift;

    my $program = 'gzip';
    my @program_opt = ( '-dc', '-f' );

    if ( !open( CSV, '-|' ) ) {
        if ( !exec( $program, @program_opt, $database ) ) {
            die "$program, @program_opt, $database: $!\n";
        }
    }

    my ( $key, $val );
    my $hash;

    while (<CSV>) {
        chomp;
        ( $key, $val ) = split $csv_delimiter;
        $hash->{$key} = $val;
    }

    return $hash;

}

sub read_database {
    my $database = shift;

    my $hash = {};

    if ( $database && -f $database ) {
        if ( $database =~ /\.csv(\.gz)?$/ ) {
            $hash = retrieve_csv($database);
        }
        else {
            $hash = retrieve($database)
              or die "Storable.pm retrieve error for database '$database'\n";
        }
    }
    else {
        warn "database '$database' does not exists (yet) or not readable!\n";
    }

    return $hash;
}

sub write_database {
    my $database = shift;
    my $hash     = shift;
    my $counter  = shift;
    $counter = "unknown" if !defined $counter;

    if ( $counter ne 'unknown' && $counter == 0 ) {
        warn "updates: $counter\n" if $debug;
        return;
    }

    return if !$database;
    if ( $test_mode || $readonly_database ) {
        warn "updates: $counter\n" if $debug;
        return;
    }

    my $database_in = $database;

    # always store in a storable file .db
    $database =~ s/\.csv(\.gz)$/.db/;

    warn "Store hash in file '$database', updates: $counter\n" if $debug;

    # atomic store of data
    my $new_db = "$database.new";
    store( $hash, $new_db ) or die "Write Storable.pm store: $new_db: $!\n";
    rename( $new_db, $database ) or die "rename $new_db -> $database: $!\n";

}

sub check_database {
    my $hash = shift;

    while ( my ( $key, $val ) = each %$hash ) {

        # unknown value
        next if $val eq "" && is_latlng($key);

        print "$key => $val\n"
          if !is_height($val) || !is_latlng($key) || $val == -32768;
    }
}

sub dump_csv {
    my $hash = shift;

    while ( my ( $key, $val ) = each %$hash ) {
        print $key, $csv_delimiter, $val, "\n";
    }
}

sub round {
    my $number = shift;

    # avoid rounding errors, add +/- 0.01
    $number =
      int( $number * $granularity + ( $number > 0 ? 0.01 : -0.01 ) ) /
      $granularity;

    return $number;
}

sub round_latlng {
    my $latlng = shift;

    my ( $lat, $lng ) = split( /,/, $latlng );
    my $newkey = &round($lat) . "," . &round($lng);

    return $newkey;
}

sub is_latlng {
    my $latlng = shift;

    return ( defined $latlng && $latlng =~ /^[\d\-\,\.e]+$/ ) ? 1 : 0;
}

sub is_height {
    my $height = shift;

    return ( defined $height && $height =~ /^[\-\+]?\d+$/ ) ? 1 : 0;
}

sub repair_database {
    my $hash     = shift;
    my $database = shift;

    my $counter = 0;
    while ( my ( $key, $val ) = each %$hash ) {
        if ( defined $val && $val eq "" ) {
        }
        elsif ( !defined $val || $val eq "-32768" || !is_height($val) ) {
            warn "key: $key, val: '$val'\n";
            $val = "";
            $hash->{$key} = $val;

            $counter++;
        }

        if ( !is_latlng($key) ) {
            warn "Delete '$key' => '$val'\n" if $debug >= 2;
            delete $hash->{$key};
            $counter++;
        }

        # round values to 1 meter granularity
        elsif ($granularity) {
            my $newkey = &round_latlng($key);

            if ( $key ne $newkey ) {
                warn "Rename key: '$key' -> '$newkey'\n" if $debug >= 2;
                $hash->{$newkey} = $hash->{$key};
                delete $hash->{$key};
                $counter++;
            }
        }
    }

    &write_database( $database, $hash, $counter );
}

sub set_signal_handler {
    my %args              = @_;
    my $database          = $args{'database'};
    my $hash              = $args{'hash'};
    my $readonly_database = $args{'readonly_database'};

    return if $readonly_database;
    return if !$database;

    $SIG{HUP} = $SIG{ALRM} = sub { &write_database( $database, $hash ); };

    # Linux has no SIGINFO. Damn!
    $SIG{INFO} = $SIG{HUP} if !-e "/proc";

    $SIG{INT} = sub { &write_database( $database, $hash ); exit(0) };
}

sub download_uri {
    my $ua   = shift;
    my $uri  = shift;
    my $city = shift || "";

    warn "download URL for city: $city $uri\n" if $debug >= 2;
    return if $test_mode || $readonly_database;

    my $response = $ua->get($uri);
    if ( $response->is_success ) {
        my $data = $response->decoded_content;    # or whatever
        return $data;
    }
    else {
        warn "Download failed: ", $response->status_line, "\n";
    }
}

sub activate_socksproxy {
    my $ua = shift;

    if ( !$ua ) {
        warn "LWP::UserAgent is not set, ignore socks proxy!\n";
        return;
    }

    eval {
        require LWP::Protocol::socks;
        $ua->proxy( [qw(http https)] => $socksproxy );
    };

    if ($@) {
        warn "Cannot load LWP::Protocol::socks, ignore socks proxy...\n";
        return;
    }
}

sub parse_hoehe {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        next if /^\s*$/;
        next if !/^[\+\-]?[0-9]+\s+/;

        my ( $elevation, $x, $lnglat ) = split /\s+/, $_;

        warn "latlng: '$_' :: $lnglat\n" if $debug >= 3;

        next if !is_latlng($lnglat);
        $lnglat = &round_latlng($lnglat);

        if ( !$lnglat ) {
            warn "Unknown height in 'hoehe' file: $_\n" if $debug >= 2;
            next;
        }

        $hash->{$lnglat} = $elevation;
    }

    return $hash;
}

sub parse_streets {
    my $file = shift;

    my $fd = new IO::File $file, "r" or die "open '$file': $!\n";
    binmode $fd, ":bytes";

    my $hash;
    my $counter = 0;

    # Lenbachstr. (10245)     N 13.4656371,52.5047021 13.466668,52.5054634
    while (<$fd>) {
        chomp;
        next if /^\s*#/;
        s/^[^\t]*\t\S+\s+//;

        my @points = split;

        if ( $ignore_poi && $#points == 0 ) {

            # warn
            next;
        }

        foreach my $point (@points) {
            if ( exists $hash->{$point} ) {
                $hash->{$point}++;
                $counter++;
            }
            else {
                $hash->{$point} = 1;
            }
        }

    }

    warn "Corner count: $counter\n" if $debug;
    return ( $hash, $counter );
}

sub get_elevation_data {
    my $hash = shift;
    my $data = shift;
    my $ua   = shift;
    my $city = shift;

    my @data = @$data;

    # nothing to do?
    return if $#data < 0;

    my ( @lng, @lat );
    foreach my $key (@data) {
        my ( $lng, $lat ) = split ",", $key;
        push @lng, $lng;
        push @lat, $lat;
    }

    my $url =
        $api_url
      . $geonames_user
      . '&lngs='
      . join( ",", @lng )
      . '&lats='
      . join( ",", @lat );

    my $content = download_uri( $ua, $url, $city );
    if ($content) {
        warn $content if $debug >= 3;
        my @heights = split( "\r\n", $content );

        if ( $#heights != $#data ) {
            warn "odd number of heights: $#heights != $#data\n";
            Die("Give up\n") if $exit_on_error;
        }

        else {
            for ( my $i = 0 ; $i < scalar(@heights) ; $i++ ) {
                my $height = $heights[$i];
                if ( defined $height && is_height($height) ) {
                    if ( $height == $NO_DATA ) {
                        warn "unknown height for: ", $data[$i], "\n";

                        # keep negative hit cache
                        $height = "";
                    }
                    $hash->{ $data[$i] } = $height;
                }
                else {
                    warn "height '$height' is not a number!\n" if $debug >= 2;
                }
            }
        }

    }

    &mysleep($sleep);
    undef @$data;
}

# sleep in seconds.miliseconds
sub mysleep {
    my $seconds = shift || "0.5";

    return if $test_mode || $readonly_database;

    # sleep a half second
    select( undef, undef, undef, $seconds );
}

sub update_hoehe {
    my %args = @_;

    my $file   = $args{'file'};
    my $points = $args{'points'};
    my $hash   = $args{'database'};

    my $tmp = "$file.new";
    my $fd = new IO::File $tmp, "w" or die "open '$tmp': $!\n";
    binmode $fd, ":raw";

    print $fd &hoehe_header;

    foreach my $point (@$points) {
        if ( defined $hash->{$point} ) {
            print $fd $hash->{$point}, "\tX ", $point, "\n";
        }
        else {
            warn "undefined height: $point\n" if $debug >= 3;
        }
    }
    $fd->close;

    if ( -e $file ) {
        rename( $file, "$file.bak" );
    }

    rename( $tmp, $file ) or die "rename $tmp -> $file: $!\n";
}

# keep a copy of the original "hoehe" file for
# further use if the script runs again
sub get_original_hoehe_file {
    my $hoehe      = shift;
    my $hoehe_orig = $hoehe . "-orig";

    # return original file
    if ( !-e $hoehe_orig ) {
        my @args = ( "cp", "-f", $hoehe, $hoehe_orig );
        system(@args) and die "system @args: $?\n";
    }

    return $hoehe_orig;
}

sub update_city {
    my %args = @_;
    my $city = $args{'city'};
    my $ua   = $args{'ua'};
    my $hash = $args{'database'};

    my $dir = "$data_osm_dir/$city";

    my $height = &parse_hoehe( &get_original_hoehe_file("$dir/hoehe") );
    my ( $streets, $corners ) = &parse_streets("$dir/strassen");

    # point to write to "hoehe"
    my @corners = ();

    # fill database with data from "hoehe" file
    while ( my ( $key, $val ) = each %$height ) {
        push @corners, $key;
        if ( !exists $hash->{$key} ) {
            $hash->{$key} = $val;
        }
    }

    my $c       = 0;
    my $counter = 0;
    my $newkey;

    # points to update
    my @data;
    while ( my ( $key, $val ) = each %$streets ) {

        # no corner
        next if $val == 1;

        # all corners
        push @corners, $key;

        if ( exists $hash->{$key} ) {
            warn "found: $key\n" if $debug >= 3;
            next;
        }

        $newkey = &round_latlng($key);

        # a rounded point exists?
        if ( $newkey ne $key && exists $hash->{$newkey} ) {
            warn "found rounded: $key\n" if $debug >= 3;
            $hash->{$key} = $hash->{$newkey};
        }

        else {
            push @data, $key;
            $counter++;
        }

        &get_elevation_data( $hash, \@data, $ua, $city )
          if scalar(@data) >= $max_points;

        #last if $c++ >= 40;
    }

    # the rest
    &get_elevation_data( $hash, \@data, $ua, $city );

    &update_hoehe(
        'file'     => "$dir/hoehe",
        'points'   => \@corners,
        'database' => $hash
    ) if !$test_mode;

    return ( $hash, $counter, $corners );
}

######################################################################
# main
#

my $help;
GetOptions(
    "help"              => \$help,
    "debug=i"           => \$debug,
    "database=s"        => \$database,
    "socksproxy=s"      => \$socksproxy,
    "geonames-user=s"   => \$geonames_user,
    "readonly-database" => \$readonly_database,
    "data-osm-dir=s"    => \$data_osm_dir,
    "user-agent=s"      => \$user_agent,
    "check-database"    => \$check_database,
    "repair-database"   => \$repair_database,
    "test-mode"         => \$test_mode,
    "exit-on-error=i"   => \$exit_on_error,
    "dump-csv"          => \$dump_csv,
) or usage;

&usage if $help;

my $hash = read_database($database);

if ($check_database) {
    &check_database($hash);
    exit;
}
elsif ($dump_csv) {
    &dump_csv($hash);
    exit;
}

# set signal handler to save state of the database
&set_signal_handler(
    'database'          => $database,
    'hash'              => $hash,
    'readonly_database' => $readonly_database
);

if ($repair_database) {
    &repair_database( $hash, $database );
    exit;
}

my @cities = @ARGV;
&usage("Missing the cities!\n") if !@cities;

# set networking
my $ua = LWP::UserAgent->new;
$ua->agent($user_agent);
activate_socksproxy($ua) if $socksproxy;

my $counter;
my $total_counter = 0;
my $total_corners = 0;

# walk throught the list of cities
foreach my $city (@cities) {
    warn "City: $city\n" if $debug;
    my $corners;
    ( $hash, $counter, $corners ) =
      &update_city( 'city' => $city, 'ua' => $ua, 'database' => $hash );
    $total_counter += $counter;
    $total_corners += $corners;

    # write database
    &write_database( $database, $hash, $counter )
      if !$readonly_database;
}

warn "\nCorners checked: $total_corners\n" if $debug;
warn "Total updates: $total_counter\n"     if $debug;

